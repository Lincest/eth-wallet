# 账户管理

采用两张表保存用户的账户信息

- **wallet**

```go
type Wallet struct {
	Model

	UID                uint   `gorm:"unique" json:"uid" form:"uid"`                     // 用户ID
	BaseDerivationPath string `json:"base_derivation_path" form:"base_derivation_path"` // 衍生路径base  e.g. [m/44'/60'/0'/0]
	LastAccountIndex   uint   `json:"last_account_index" form:"last_account_index"`     // 衍生路径[base_derivation_path/account_index]的最后一个account_index
}
```

- **accounts**

```go
type Accounts struct {
	Model

	UID            uint           `json:"uid" form:"uid"`                         // 用户ID
	DerivationPath string         `json:"derivation_path" form:"derivation_path"` // 衍生路径 e.g. [m/44'/60'/0'/0/1]
	Address        common.Address `json:"address" form:"address"`                 // 地址
}
```

## 功能

### 生成新钱包

- 首先判断用户是否存在wallet
- 如果不存在wallet, 在wallet表中新建wallet
- 向accounts表中添加一条信息

其中后两条包含在一个事务中

```go
// InitWallet 为用户新建一个钱包
func (srv *walletService) InitWallet(uid uint) error {
	// 检查用户是否有助记词
	user := model.User{}
	if err := db.First(&user, uid).Error; err != nil {
		return err
	}
	if user.Mnemonic == "" {
		return fmt.Errorf("用户未创建助记词")
	}
	// 检查用户是否已经创建钱包
	iwallet := &model.Wallet{UID: uid}
	if err := db.Where(iwallet).First(iwallet).Error; err == nil {
		return fmt.Errorf("用户已经创建钱包, 最新的衍生路径为 = %s", fmt.Sprintf("%s/%d", iwallet.BaseDerivationPath, iwallet.LastAddressIndex))
	}
	// 为用户新建钱包
	wallet, err := hdwallet.NewFromMnemonic(user.Mnemonic)
	if err != nil {
		return err
	}
	basePath, err := hdwallet.ParseDerivationPath(fmt.Sprintf("%s/%d", conf.Config.Wallet.BasePath, 0))
	if err != nil {
		return err
	}
	account, err := wallet.Derive(basePath, false)
	newWallet := model.Wallet{UID: uid, BaseDerivationPath: conf.Config.Wallet.BasePath, LastAddressIndex: 0}
	// 开启事务: 1. 新建钱包 2. 新增账户
	tx := db.Begin()
	if err := tx.Create(&newWallet).Error; err != nil {
		tx.Rollback()
		return err
	}
	newAccount := model.Account{UID: uid, DerivationPath: basePath.String(), Address: account.Address}
	if err := tx.Create(&newAccount).Error; err != nil {
		tx.Rollback()
		return err
	}
	tx.Commit()
	return nil
}
```

### 新增账户

- 根据wallets表记录确定用户最后一条衍生路径, (account_index + 1)
- 根据新的衍生路径和用户助记词创建新账户
- wallets表中last_account_index + 1
- accounts表中新增一条账户

```go
func (srv *walletService) AddNewAccount(uid uint) error {
	wallet := model.Wallet{UID: uid}
	// 没有钱包时, 首先新增钱包
	if err := db.First(&wallet).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			if err = srv.InitWallet(uid); err != nil {
				return err
			}
			return nil
		}
	}
	// 如果有钱包了, 就根据最新衍生路径新建账户
	lastPath := fmt.Sprintf("%s/%d", wallet.BaseDerivationPath, wallet.LastAccountIndex)
	newPath, err := utils.Wallet.GetNewDerivationPath(lastPath)
	if err != nil {
		return err
	}
	mnemonic, err := Mnemonic.GetMnemonicByUid(uid)
	if err != nil {
		return err
	}
	if mnemonic == "" {
		return fmt.Errorf("用户未创建助记词")
	}
	newAccount, err := srv.GenerateNewAccount(mnemonic, newPath)
	if err != nil {
		return err
	}
	tx := db.Begin()
	if err := tx.Create(&model.Account{UID: uid, DerivationPath: newPath, Address: newAccount.Address}).Error; err != nil {
		tx.Rollback()
		return err
	}
	wallet.LastAccountIndex += 1
	if err := tx.Save(&wallet).Error; err != nil {
		tx.Rollback()
		return err
	}
	tx.Commit()
	return nil
}
```

#### 生成新的衍生路径

- 读取数据库最后一次的衍生路径 `BaseDerivationPath + / + LastAddressIndex `
- 根据最后一次的衍生路径生成新的衍生路径

```go
func (*IWallet) GetNewDerivationPath(lastPath string) (string, error) {
	pathSplits := strings.Split(lastPath, "/")
	lastAccountIndex, err := strconv.Atoi(pathSplits[len(pathSplits) - 1])
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s/%d", conf.Config.Wallet.BasePath, lastAccountIndex + 1), nil
}
```

